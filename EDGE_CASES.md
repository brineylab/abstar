# Edge Case Test Implementation Plan

## Overview

This document describes a comprehensive test suite for antibody region annotation edge cases. The `test_50.csv` file contains 50 normal, unmutated antibody sequences with known correct region annotations (FWR1-4, CDR1-3 at both nucleotide and amino acid levels). These sequences serve as ground truth baselines from which synthetic edge case sequences are programmatically generated by introducing specific modifications (insertions, deletions, truncations, mutations). Each modification has predictable effects on the expected annotation output, enabling rigorous validation of the annotation pipeline.

The test suite includes both **unit tests** (testing `get_region_sequence()` and `identify_cdr3_regions()` directly with crafted alignment objects) and **end-to-end integration tests** (running modified sequences through `abstar.run()` and validating all region annotations).

## Implementation Constraints & Known Behaviors

These constraints are based on current `abstar` implementation and must drive test expectations:

- **Productivity is rule-based, not purely modulo-3 based**:
  `productive` is determined from translated sequence and junction/locus checks (for example stop codon, conserved C/W/F, locus mismatch, ambiguous nucleotides), not from indel length arithmetic alone.
- **Region boundaries are alignment-derived**:
  Upstream indels/high-SHM can shift nearby region boundaries; exact equality of downstream regions is not always guaranteed even when biology suggests "unaffected".
- **`get_region_sequence()` contract is tuple-oriented with one compatibility edge path**:
  The standard return form is `(region_start, region_end, region_sequence)`, but the fully-missing-region path may return `""`; unit tests should normalize before assertion.
- **Gap handling differs by region source**:
  V-region sequences are gap-stripped by `get_region_sequence()`. FWR4 is extracted from J-gene alignment in the annotator path, so no-gap assertions for FWR4 should only be made when guaranteed.

---

## Files to Create

| File | Purpose |
|------|---------|
| `abstar/tests/edge_case_helpers.py` | Sequence modification utility functions |
| `abstar/tests/test_region_edge_cases.py` | All edge case tests (unit + integration) |

## Files to Modify

| File | Change |
|------|--------|
| `abstar/tests/conftest.py` | Add ground truth CSV loading fixtures |

## Key Existing Files (Read-Only Reference)

| File | Relevance |
|------|-----------|
| `abstar/test_data/test_50.csv` | Ground truth sequences and expected regions |
| `abstar/annotation/regions.py` | `get_region_sequence()`, `identify_cdr3_regions()`, IMGT position constants |
| `abstar/annotation/annotator.py` | Full annotation pipeline, region extraction calls (lines 952-1007) |
| `abstar/annotation/antibody.py` | `Antibody` dataclass with all region fields |
| `abstar/tests/test_regions.py` | Existing region tests (pattern reference) |
| `abstar/tests/conftest.py` | Existing test fixtures |

---

## Ground Truth Data Structure

Each row in `test_50.csv` contains:

```
sequence_id      - Unique identifier (e.g., "ATCCGAACAGCTGCAC-1_heavy")
sequence_input   - Full input nucleotide sequence
fwr1, cdr1, fwr2, cdr2, fwr3, cdr3, fwr4       - NT region sequences
fwr1_aa, cdr1_aa, fwr2_aa, cdr2_aa, fwr3_aa, cdr3_aa, fwr4_aa  - AA region sequences
```

**Critical property**: For every row, `fwr1 + cdr1 + fwr2 + cdr2 + fwr3 + cdr3 + fwr4 == sequence_input`. This means each input sequence is exactly the concatenation of all its regions, with no leader or constant region overhang. This property enables precise computation of region boundary positions and predictable expected outputs after modification.

The dataset includes:
- 25 heavy chains (`_heavy` suffix) - IGH locus with D-gene
- 25 light chains (`_light` suffix) - both kappa (IGK) and lambda (IGL)

---

## Testing Infrastructure

### Fixtures (added to `conftest.py`)

```python
@pytest.fixture(scope="module")
def ground_truth_sequences():
    """Load all 50 ground truth sequences with their known regions."""
    # Load with encoding="utf-8-sig" to handle UTF-8 BOM in CSV header.
    # Validate required columns:
    # ["sequence_id", "sequence_input", "fwr1", "cdr1", "fwr2", "cdr2",
    #  "fwr3", "cdr3", "fwr4", "fwr1_aa", "cdr1_aa", "fwr2_aa", "cdr2_aa",
    #  "fwr3_aa", "cdr3_aa", "fwr4_aa"]
    # Returns list of dicts from test_50.csv.

@pytest.fixture(scope="module")
def heavy_chain_ground_truth(ground_truth_sequences):
    """Filter to heavy chain sequences only."""

@pytest.fixture(scope="module")
def light_chain_ground_truth(ground_truth_sequences):
    """Filter to light chain sequences only."""
```

### Helper Functions (`edge_case_helpers.py`)

#### Region Boundary Mapping

```python
def get_region_boundaries(row: dict) -> dict:
    """
    Compute (start, end) positions for each region within the full input sequence.

    Returns dict mapping region name to (start, end) tuple where start is inclusive
    and end is exclusive (suitable for Python slicing).

    Example for a sequence with FWR1=75nt, CDR1=24nt, FWR2=51nt, ...:
        {"fwr1": (0, 75), "cdr1": (75, 99), "fwr2": (99, 150), ...}
    """
```

#### Sequence Modification Functions

```python
def insert_at_position(sequence, position, insertion) -> str
def delete_at_position(sequence, position, length) -> str
def insert_at_region_boundary(row, boundary, insertion, offset=0) -> str
def delete_at_region_boundary(row, boundary, length, offset=0) -> str
def truncate_5prime(row, num_bases) -> str
def truncate_3prime(row, num_bases) -> str
def truncate_to_region(row, start_region) -> str
def mutate_position(sequence, position, replacement_base=None) -> str
def mutate_near_boundary(row, boundary, num_mutations, window=6, seed=0) -> str
def extend_cdr3(row, extension) -> str
def shorten_cdr3(row, bases_to_remove) -> str
```

Determinism requirements for helper functions:

- Mutation helpers must be deterministic in CI: use either fixed mutation maps or a fixed RNG seed.
- If randomization is used for position choice, expose `seed` and include it in parametrization IDs for reproducibility.
- Base substitutions must avoid identity substitutions (`A->A`, etc.) and avoid introducing accidental stop codons unless the test explicitly targets stop codons.

### Assertion Strategy

Assertions are tiered based on predictability:

**Tier 1 - Exact match**:

- Baseline tests on unmodified sequences: all 14 region fields match CSV exactly.
- Regions far from perturbation where implementation guarantees stability.

**Tier 2 - Property-based**: For affected regions:

- V-region outputs (`fwr1`, `cdr1`, `fwr2`, `cdr2`, `fwr3`) contain no `-`.
- Adjacent-region aggregate invariants at modified boundaries (for example `len(fwr1)+len(cdr1)` delta).
- AA regions are correct translations of NT regions when NT length is divisible by 3.
- Region lengths are within expected tolerance of ground truth for alignment-sensitive regions.
- Pipeline completes without crashing (`result is not None`).

**Tier 3 - Productivity/functional**:

- Assert productivity fields are populated and biologically consistent with the specific perturbation.
- Do **not** assume non-codon indels automatically imply `productive == False`.
- For explicit stop-codon tests: assert `productive == False`, `stop_codon == True`, and `productivity_issues` includes a stop-codon reason.

Strict-vs-tolerant guidance:

- Use strict equality for baseline and clearly unaffected upstream regions.
- Use tolerance/property assertions for boundary-adjacent and downstream regions after indels or heavy SHM.

### Test Organization

```
TestGroundTruthBaseline              - Baseline validation (50 sequences)
TestGetRegionSequenceEdgeCases       - Unit tests (get_region_sequence directly)
TestIndelAtBoundary                  - Edge case 1
TestTrimmedJGene                     - Edge case 2
TestComplementaryFrameshifts         - Edge case 3
TestFivePrimeTruncation              - Edge case 4
TestThreePrimeTruncation             - Edge case 5
TestHighSHMAtBoundaries              - Edge case 6
TestCDRInsertions                    - Edge case 7
TestFWRDeletions                     - Edge case 8
TestCDR3LengthExtremes               - Edge case 9
TestMultipleIndels                   - Edge case 10
TestStopCodons                       - Edge case 11
TestRegionConsistency                - Cross-cutting consistency checks
TestOrientationRobustness            - Edge case 13
TestAmbiguousNucleotides             - Edge case 14
TestDegenerateAlignments             - Edge case 15
TestCDR3FallbackPaths                - Edge case 16
```

---

## Edge Case Descriptions

### Baseline: Ground Truth Validation

**Purpose**: Before testing edge cases, validate that all 50 unmutated sequences annotate correctly. This serves as a sanity check and regression baseline.

**Implementation**: Parametrize over all 50 rows. For each sequence, run through `abstar.run()` and assert all 14 region fields (7 NT + 7 AA) match the CSV values exactly.

**Example**:
```
Input:  ATCCGAACAGCTGCAC-1_heavy sequence
Expect: fwr1 == "caggtgcagctacagcag..."
        cdr1 == "ggtgggtccttcagtggttactac"
        fwr1_aa == "QVQLQQWGAGLLKPSETLSLTCAVY"
        ...all 14 fields match CSV...
```

---

### Edge Case 1: Indels at or Near Region Boundaries

**Biological context**: Somatic hypermutation (SHM) can introduce insertions and deletions anywhere in the V-gene, but indels near region boundaries are particularly problematic for annotation because they shift the alignment coordinates used to determine where one region ends and the next begins. When an indel occurs mid-codon and spans a region boundary, the true boundary position becomes ambiguous because the codon "belongs" to both regions.

The `get_region_sequence()` function in `regions.py` (lines 174-200) already has special handling for this scenario -- it detects non-codon-length gaps at region boundaries and applies "codon-stealing" logic to assign partial codons to the region where the codon starts. This edge case suite validates that logic.

#### 1a: Codon-length (3-nt) deletion spanning a region boundary

**Modification**: Delete 3 nucleotides that straddle the boundary between two adjacent regions (e.g., last 1 nt of FWR1 + first 2 nt of CDR1).

**Example**:
```
Ground truth:
  FWR1: ...GCAAGGCTTCT     (ends at position 74)
  CDR1: GGATACACCTTCACC...  (starts at position 75)

Modified (delete 3 nt spanning boundary, offset=-1):
  ...GCAAGGCTTC | T GGA | TACACCTTCACC...
                  ^^^^^ deleted
  Result: ...GCAAGGCTTCTACACCTTCACC...

Expected behavior:
  - Pipeline should not crash
  - Combined length of FWR1 + CDR1 should be exactly 3 nt shorter than original
  - Assignment of the deleted codon can shift between the two adjacent regions; validate aggregate pair behavior rather than exact per-region split
  - Non-adjacent regions should remain stable (exact where practical; tolerant near secondary boundaries)
  - No gap characters in V-region outputs
```

**Tests**:
- Deletion spanning FWR1/CDR1 boundary
- Deletion spanning CDR1/FWR2 boundary
- Deletion spanning FWR2/CDR2 boundary
- Deletion spanning CDR2/FWR3 boundary
- Deletion spanning FWR3/CDR3 boundary (most critical -- this is where the junction is)

#### 1b: Non-codon-length (1-nt, 2-nt) deletion at a boundary

**Modification**: Delete 1 or 2 nucleotides exactly at or near a region boundary, causing a reading frame shift.

**Example**:
```
Ground truth:
  FWR2: ...TGGAGTGGATGGGATGG  (ends at position 165)
  CDR2: ATCAACCCTAAC...        (starts at position 166)

Modified (delete 2 nt at boundary):
  ...TGGAGTGGATGGGATGG | AT | CAACCCTAAC...
                         ^^ deleted
  Result: ...TGGAGTGGATGGGATGGCAACCCTAAC...

Expected behavior:
  - Pipeline should not crash
  - Region sequences should still be extracted (even if frame-shifted)
  - `productive` and `productivity_issues` should be populated with biologically consistent outcomes
  - The codon-stealing logic should handle the non-codon-length gap
```

**Tests** (parametrized over deletion length 1 and 2):
- At FWR1/CDR1 boundary
- At FWR2/CDR2 boundary
- At FWR3/CDR3 boundary

#### 1c: Codon-length (3-nt) insertion at a region boundary

**Modification**: Insert 3 nucleotides exactly at the boundary between two regions.

**Example**:
```
Ground truth:
  CDR2: ATCAACCCTAACAGTGGTGGCACA  (ends at position 195)
  FWR3: AACTATGCACAGAAG...         (starts at position 196)

Modified (insert AAA at boundary):
  ...ATCAACCCTAACAGTGGTGGCACA | AAA | AACTATGCACAGAAG...
                                ^^^ inserted

Expected behavior:
  - Pipeline should not crash
  - Insertion could be assigned to CDR2 or FWR3 (either is acceptable)
  - Total length of CDR2 + FWR3 should be original + 3
  - Sequence should remain in-frame and potentially productive
  - Downstream regions should be stable, but boundary-adjacent regions are validated with tolerant/property-based assertions
```

#### 1d: Non-codon-length (2-nt) insertion at a boundary (mid-codon spanning)

**Modification**: Insert 2 nucleotides 1 position before a region boundary, splitting a codon across the boundary.

**Example**:
```
Ground truth:
  FWR3: ...GTGTATTACTGTGCG  (last codon is GCG, ends at position 312)
  CDR3: AGAGGCGTTTTAGTG...   (starts at position 313)

Modified (insert AG at position 311, 1 before boundary):
  ...GTGTATTACTGTGC | AG | GAGAGGCGTTTTAGTG...
                      ^^ inserted mid-codon

Expected behavior:
  - Pipeline should not crash
  - Frame-disrupting behavior should be detectable in derived outputs, but productivity outcome is asserted from actual rule-based fields rather than modulo-3 arithmetic alone
  - The codon-stealing logic in get_region_sequence() should handle this:
    the GC at the end of FWR3 and the AG insertion + G at start of CDR3
    create a non-codon-length gap scenario
  - No gap characters in V-region outputs
```

#### 1e: Large (6-nt, 9-nt) codon-length insertion at boundary

**Modification**: Insert 6 or 9 nucleotides at a boundary to test that the logic handles multi-codon insertions.

**Tests**: Parametrized with insertion sizes [3, 6, 9] at CDR1/FWR2 and CDR2/FWR3 boundaries.

---

### Edge Case 2: Heavily Trimmed J-Gene in Light Chains

**Biological context**: During V(D)J recombination, the ends of gene segments are trimmed by exonucleases before joining. In light chains, the J-gene can occasionally be trimmed so extensively that the conserved Phe (F) or Trp (W) codon that normally marks the start of FWR4 is no longer encoded by the J-gene -- instead, it comes from the 3' end of the V-gene or from N-addition. The annotator extracts FWR4 from the J-gene alignment (`annotator.py` lines 999-1004), so extreme trimming could produce an incorrect or truncated FWR4.

#### 2a: Remove most of FWR4 (simulating heavy J-gene trimming)

**Modification**: Truncate the 3' end of a light chain sequence to remove all but the last 6 nucleotides (2 codons) of FWR4.

**Example**:
```
Ground truth (light chain):
  CDR3: cagcaatattatagtactccgtacact
  FWR4: tttggccaggggaccaagctggagatcaaac  (31 nt)

Modified (keep only last 6 nt of FWR4):
  ...cagcaatattatagtactccgtacactatcaaac
  FWR4 remaining: atcaaac (6 nt -- the last 2 codons)

Expected behavior:
  - Pipeline should still identify CDR3/junction without crashing
  - FWR4 should be shorter than original
  - FWR4 should be asserted using explicit empty-value normalization (`""` vs `None`) where needed
```

#### 2b: Remove FWR4 entirely

**Modification**: Truncate to end exactly at the CDR3/FWR4 boundary.

**Example**:
```
Ground truth (light chain):
  ...cagcaatattatagtactccgtacact | tttggccaggggaccaagctggagatcaaac
       CDR3                        FWR4 (entirely removed)

Modified: sequence ends after CDR3
  ...cagcaatattatagtactccgtacact

Expected behavior:
  - CDR3 may still be identifiable
  - FWR4 should be empty/None (assert via normalized empty representation)
  - No crash
```

#### 2c: J-gene trimmed to conserved codon only

**Modification**: Keep only the first 3 nucleotides of FWR4 (the conserved F/W codon).

**Example**:
```
Ground truth (light chain):
  FWR4: tttggccaggggaccaagctggagatcaaac  (31 nt)

Modified: keep only "ttt" (the Phe codon)
  ...cagcaatattatagtactccgtacactttt

Expected behavior:
  - FWR4 should be "ttt" or empty (depending on minimum alignment length)
  - CDR3 should remain intact or show only boundary-local shifts
```

#### 2d: Apply to multiple light chain gene families

**Tests**: Run 2a-2c on both kappa and lambda light chains from the test set, since they use different J-gene families (IGKJ vs IGLJ) with different conserved motifs. Also assert locus remains IGK/IGL and D-gene remains absent.

---

### Edge Case 3: Complementary Frameshifts

**Biological context**: V(D)J recombination can introduce frameshifts when gene segments are joined out-of-frame. However, in rare cases, a separate indel event (from SHM or recombination) can compensate for the first, restoring the reading frame. For example:
- A 2-nt deletion in the V-gene shifts the frame by -2
- An "out-of-frame" J-gene junction (where the J reading frame is offset by +1 relative to the V) would normally be non-productive
- Combined, -2 + (+1 from the out-of-frame J) = -1, which is still out of frame
- But if combined with a 1-nt insertion elsewhere, -2 + 1 + (out-of-frame J) could restore frame

The key question: does the annotation pipeline correctly identify regions when there are compensating frameshifts?

#### 3a: 2-nt deletion in FWR2 + 1-nt insertion in FWR3 (net -1, frame-disrupting)

**Modification**: Delete 2 nt from FWR2 and insert 1 nt in FWR3.

**Example**:
```
Ground truth:
  FWR2: ...TGGAGTGGATGGGATGG  (51 nt)
  FWR3: ...AACTATGCACAGAAG... (117 nt)

Modified:
  - Delete 2 nt at FWR2 position +10: removes "GG" â†’ FWR2 region is 49 nt
  - Insert "G" at FWR3 position +10: FWR3 region becomes 118 nt
  - Net: -2 + 1 = -1 (frameshift)

Expected behavior:
  - Net indel arithmetic is frame-disrupting (`-1`)
  - Regions should still be extracted
  - Region boundaries may shift slightly due to alignment effects
  - Productivity assertions should check rule-based outputs (`productive`, `stop_codon`, `productivity_issues`) instead of forcing `productive == False`
```

#### 3b: 2-nt deletion + 2-nt insertion (net 0, in-frame, potentially productive)

**Modification**: Delete 2 nt from FWR2 and insert 2 nt in FWR3 (separated by CDR2).

**Example**:
```
Modified:
  - Delete 2 nt at FWR2 position +15
  - Insert "AG" at FWR3 position +20
  - Net: -2 + 2 = 0 (in-frame)

Expected behavior:
  - Sequence remains in-frame
  - Could still be productive (if no stop codons or junction/locus rule violations are introduced)
  - Both affected regions should have altered lengths
  - CDR2 (between the two indels) should be approximately unchanged
  - Regions after FWR3 should be validated with tolerant assertions near boundaries
```

#### 3c: 1-nt deletion in V-gene + 2-nt deletion in V-gene (net -3, in-frame)

**Modification**: Two separate non-codon-length deletions that sum to a codon-length change.

**Example**:
```
Modified:
  - Delete 1 nt at FWR2 position +10
  - Delete 2 nt at FWR3 position +20
  - Net: -3 (in-frame, one codon removed)

Expected behavior:
  - Sequence remains in-frame
  - Could be productive depending on downstream rule checks
  - The annotator should recognize these as separate indel events
```

#### 3d: 1-nt insertion in CDR1 + 2-nt insertion in CDR2 (net +3, in-frame)

**Modification**: Two non-codon-length insertions that sum to a codon-length insertion.

**Example**:
```
Modified:
  - Insert "A" in middle of CDR1
  - Insert "TG" in middle of CDR2
  - Net: +3 (in-frame, one codon added)

Expected behavior:
  - Sequence remains in-frame
  - Could be productive depending on downstream rule checks
  - CDR1 and CDR2 lengths should each change
  - FWR1, FWR2, FWR3 should be approximately unchanged
```

---

### Edge Case 4: 5' Truncated Sequences

**Biological context**: Sequencing reads, especially from short-read platforms, often don't cover the full V-gene. The 5' end (FWR1) is most commonly truncated. The `get_region_sequence()` function handles this by checking if `gapped_germline_start > imgt_end` (line 98 of `regions.py`) and returning an empty string for fully missing regions.

#### 4a: Missing entire FWR1

**Modification**: Truncate sequence to start at the beginning of CDR1.

**Example**:
```
Ground truth:
  sequence_input = FWR1 + CDR1 + FWR2 + CDR2 + FWR3 + CDR3 + FWR4
  FWR1 is 75 nt

Modified: remove first 75 nt (all of FWR1)
  sequence_input = CDR1 + FWR2 + CDR2 + FWR3 + CDR3 + FWR4

Expected behavior:
  - FWR1 should be "" or None
  - CDR1 should match ground truth exactly
  - FWR2 onward should remain stable, with tolerant assertions for any boundary-adjacent shifts
```

#### 4b: Partial FWR1 (first 20 nt removed)

**Modification**: Remove first 20 nucleotides.

**Example**:
```
Ground truth FWR1: caggtgcagctacagcagtggggcgcaggactgttgaagccttcggagaccctgtccctcacctgcgctgtctat (75 nt)

Modified: remove first 20 nt
  Remaining FWR1: gcaggactgttgaagccttcggagaccctgtccctcacctgcgctgtctat (55 nt)

Expected behavior:
  - FWR1 should be the remaining 55 nt (or a substring of it depending on alignment)
  - len(result["fwr1"]) < len(ground_truth["fwr1"])
  - CDR1 onward should be stable, using tolerant checks near boundaries
```

#### 4c: Deep truncation past FWR1 and CDR1 (into FWR2)

**Modification**: Truncate to the middle of FWR2.

**Example**:
```
Modified: remove FWR1 (75 nt) + CDR1 (24 nt) + first 15 nt of FWR2

Expected behavior:
  - FWR1 should be "" or None
  - CDR1 should be "" or None
  - FWR2 should be partial (shorter than ground truth)
  - CDR2 onward should be stable, using tolerant checks near boundaries
```

#### 4d: Extreme truncation (start in FWR3)

**Modification**: Truncate everything before FWR3.

**Example**:
```
Modified: sequence starts at FWR3

Expected behavior:
  - FWR1, CDR1, FWR2, CDR2 should all be "" or None
  - FWR3 should match ground truth (or close to it)
  - CDR3, FWR4 should be stable, with tolerant checks at boundaries
```

---

### Edge Case 5: 3' Truncated Sequences

**Biological context**: The 3' end of the sequence may be truncated due to sequencing limitations or because the J-gene was heavily trimmed during recombination. FWR4 is extracted from the J-gene alignment (not IMGT positions), so 3' truncation affects FWR4 extraction.

#### 5a: Missing entire FWR4

**Modification**: Truncate at the CDR3/FWR4 boundary.

**Example**:
```
Ground truth:
  CDR3: gcgagaggcgttttagtggctggtacgagccggtggttcgacccc
  FWR4: tggggccagggaaccctggtcaccgtctcctcag

Modified: remove FWR4 entirely
  Sequence ends at: ...gcgagaggcgttttagtggctggtacgagccggtggttcgacccc

Expected behavior:
  - FWR4 should be "" or None
  - CDR3 should still be identifiable
  - V-gene regions (FWR1-3, CDR1-2) should be exact matches
```

#### 5b: Partial FWR4 (last 15 nt removed)

**Modification**: Remove last 15 nucleotides.

**Example**:
```
Ground truth FWR4: tggggccagggaaccctggtcaccgtctcctcag (35 nt)

Modified: FWR4 becomes first 20 nt only
  tggggccagggaaccctggt (20 nt)

Expected behavior:
  - FWR4 should be shorter than ground truth
  - All other regions should remain stable (strict for clearly unaffected regions, tolerant near boundaries)
```

#### 5c: Truncation into CDR3

**Modification**: Remove FWR4 + last portion of CDR3.

**Example**:
```
Modified: sequence ends 10 nt before the CDR3/FWR4 boundary
  CDR3 is truncated by 10 nt from its 3' end

Expected behavior:
  - CDR3 should be shorter than ground truth
  - FWR4 should be "" or None
  - V-gene regions should be exact matches
```

---

### Edge Case 6: High SHM Near Region Boundaries

**Biological context**: Somatic hypermutation introduces point mutations throughout the V-gene, with hotspots in CDR regions. When multiple mutations cluster near a boundary between two regions, the alignment score may drop enough to cause the aligner to introduce gaps or misplace the boundary. The `get_region_sequence()` function uses the full germline alignment (not local) specifically to avoid SHM-related truncation issues (noted in the docstring at lines 36-47 of `regions.py`).

#### 6a: 4-6 mutations clustered at CDR1/FWR2 boundary

**Modification**: Apply 4-6 point mutations within a 12-nt window centered on the CDR1/FWR2 boundary.

**Example**:
```
Ground truth:
  CDR1 end:  ...GTTACTAC
  FWR2 start: TGGAGCTGG...

Modified (4 mutations, window=6 on each side):
  CDR1 end:  ...GTTCGTAG      (2 mutations in CDR1)
  FWR2 start: TGCACATGG...    (2 mutations in FWR2)

Expected behavior:
  - Region boundaries should be maintained correctly despite mutations
  - CDR1 and FWR2 lengths should match ground truth (mutations don't change length)
  - The mutated residues should appear in the output region sequences
```

#### 6b: 6-8 mutations clustered at FWR3/CDR3 boundary

**Modification**: Apply 6-8 mutations near the FWR3/CDR3 boundary (the most critical boundary for annotation accuracy).

**Example**:
```
Ground truth:
  FWR3 end:   ...TGTATTACTGTGCG
  CDR3 start:  AGAGGCGTTTTAGTG...

Modified (6 mutations):
  FWR3 end:   ...TGTACTAATGTGCG   (3 mutations)
  CDR3 start:  CGCGGCGTCTTAATG... (3 mutations)

Expected behavior:
  - Region lengths should match ground truth exactly (SHM doesn't change length)
  - Boundary should be correctly placed despite mismatches
  - abs(len(result["fwr3"]) - len(ground_truth["fwr3"])) == 0
```

#### 6c: Heavy mutation in FWR1 start (AA alignment edge case)

**Modification**: Mutate the first 2-3 codons of FWR1, which can cause the AA alignment to incorrectly truncate (the specific edge case handled at `regions.py:149-167`).

**Example**:
```
Ground truth:
  FWR1 start (NT): CAGGTGCAGCTGGTG...
  FWR1 start (AA): QVQLV...

Modified (mutate first 2 codons):
  FWR1 start (NT): GACGTGGAGGTGGTG...  (2 nt changes per codon)
  FWR1 start (AA): DVEV...

  The AA alignment may incorrectly align:
    QUERY:    DVEV--VESGGGLVQPG...
    GERMLINE: --EVQLVESGGGLVQPG...

  But the NT alignment correctly aligns:
    QUERY:    GACGTGGAGGTGGTGGAGTC...
    GERMLINE: GAGGTGCAGCTGGTGGAGTC...

Expected behavior:
  - The nt_region_start correction logic should detect that NT start=0
    but AA start>0 and adjust the AA region start to 0
  - FWR1 AA should include the mutated first residues
```

#### 6d: Parametrize over mutation counts

**Tests**: Parametrize mutation counts [2, 4, 6, 8] at boundaries CDR1/FWR2 and FWR3/CDR3 on both heavy and light chains. Use deterministic mutation generation (fixed seed or explicit mutation maps) so expectations are reproducible.

---

### Edge Case 7: Insertions Within CDR Regions

**Biological context**: During affinity maturation, SHM can introduce insertions (typically 3-9 nt) in CDR regions, particularly CDR1 and CDR2. These insertions are a key mechanism for increasing antigen-binding diversity. Codon-length insertions maintain reading frame; non-codon-length insertions cause frameshifts.

#### 7a: Codon-length (3-nt) insertion in CDR1

**Modification**: Insert 3 nucleotides in the middle of CDR1.

**Example**:
```
Ground truth CDR1: ggatacaccttcaccggctactat (24 nt, 8 codons)

Modified: insert GGG at position 12 (middle of CDR1)
  ggatacaccttc | GGG | accggctactat (27 nt, 9 codons)

Expected behavior:
  - CDR1 should be 3 nt longer than ground truth: len(result["cdr1"]) == 27
  - CDR1 AA should be 1 AA longer
  - FWR1 should match ground truth exactly (upstream, unaffected)
  - FWR2 should remain stable, with tolerant checks if boundary placement shifts
  - Sequence should remain in-frame and potentially productive
```

#### 7b: Multi-codon (6-nt, 9-nt) insertion in CDR2

**Modification**: Insert 6 or 9 nucleotides in CDR2.

**Tests**: Parametrize insertion sizes [3, 6, 9] in CDR2 middle position.

**Expected behavior**: CDR2 length increases by insertion size; surrounding regions should remain stable (strict for clearly unaffected segments, tolerant near boundaries).

#### 7c: Non-codon-length (1-nt, 2-nt, 4-nt, 5-nt) insertion in CDR1

**Modification**: Insert 1, 2, 4, or 5 nucleotides in CDR1 (causes frameshift).

**Example**:
```
Ground truth CDR1: ggatacaccttcaccggctactat (24 nt)

Modified (insert "A" at position 12):
  ggatacaccttc | A | accggctactat (25 nt -- not divisible by 3)

Expected behavior:
  - CDR1 should still be extracted (may be 25 nt)
  - `productive`, `stop_codon`, and `productivity_issues` should be populated consistently with the resulting translated sequence
```

#### 7d: Insertion in CDR3 (extending the CDR3)

**Modification**: Insert codon-length nucleotides in the middle of CDR3 to simulate extended CDR3s.

**Tests**: Insert 3, 6, 9 nt in CDR3 middle.

---

### Edge Case 8: Deletions Within FWR Regions

**Biological context**: SHM can introduce deletions in framework regions, though this is less common than in CDRs. Framework deletions can affect the structural integrity of the antibody but are observed in some broadly neutralizing antibodies.

#### 8a: Codon-length (3-nt) deletion in FWR3

**Modification**: Delete 3 nucleotides from the middle of FWR3.

**Example**:
```
Ground truth FWR3: aactatgcacagaag...gcgtgtattactgtgcg (117 nt, 39 codons)

Modified: delete 3 nt at position +50 in FWR3
  ...aactatgcacagaag...||...gcgtgtattactgtgcg (114 nt, 38 codons)

Expected behavior:
  - FWR3 should be 3 nt shorter: len(result["fwr3"]) == 114
  - FWR3 AA should be 1 AA shorter
  - CDR2 should match ground truth exactly (upstream)
  - CDR3 should remain stable, with tolerant checks near the FWR3/CDR3 boundary
  - Sequence should remain in-frame
```

#### 8b: Codon-length (3-nt) deletion in FWR1

**Modification**: Delete 3 nucleotides from the middle of FWR1.

**Expected behavior**: FWR1 is 3 shorter; CDR1 onward should remain stable (strict where clearly unaffected, tolerant near boundaries).

#### 8c: Non-codon-length (2-nt) deletion in FWR2

**Modification**: Delete 2 nucleotides from FWR2.

**Expected behavior**: Regions still extracted. Productivity fields should reflect rule-based outcome (not forced to non-productive solely from indel length).

#### 8d: Large (6-nt, 9-nt) codon-length deletion in FWR3

**Modification**: Delete 6 or 9 nucleotides from FWR3.

**Tests**: Parametrize deletion sizes [3, 6, 9].

---

### Edge Case 9: CDR3 Length Extremes

**Biological context**: CDR3 length is highly variable. Heavy chain CDR3 can range from 3 to 90+ nucleotides. Very long CDR3s are common in HIV broadly neutralizing antibodies (bnAbs) and camelid antibodies. Very short CDR3s result from extensive trimming of D and/or J gene segments.

#### 9a: Very long CDR3 (extended by 60 nt)

**Modification**: Insert 60 nt (20 codons) of in-frame sequence into the middle of CDR3.

**Example**:
```
Ground truth CDR3: gcgagaggcgttttagtggctggtacgagccggtggttcgacccc (45 nt)

Modified: insert 60 nt at CDR3 midpoint
  gcgagaggcgttttagtggctg | GGTATGGACGTCGGTATGGACGTC...x5 | gtacgagccggtggttcgacccc

Result CDR3 would be ~105 nt (35 codons)

Expected behavior:
  - CDR3 should be significantly longer than ground truth
  - V-gene regions (FWR1-3, CDR1-2) should be exact matches
  - FWR4 should be unchanged
  - Sequence should remain in-frame
```

#### 9b: Very short CDR3 (shortened to 6 nt)

**Modification**: Remove nucleotides from CDR3 center to leave only 6 nt (2 codons).

**Example**:
```
Ground truth CDR3: gcgagaggcgttttagtggctggtacgagccggtggttcgacccc (45 nt)

Modified: keep first 3 nt and last 3 nt of CDR3
  gcgccc (6 nt, 2 codons)

Expected behavior:
  - CDR3 should be very short
  - Junction should be correspondingly short
  - FWR3 and FWR4 should remain stable with tolerant checks at CDR3-adjacent boundaries
```

#### 9c: Minimal CDR3 (3 nt only)

**Modification**: Reduce CDR3 to a single codon.

**Expected behavior**: Pipeline should handle this gracefully, emit bounded CDR3/junction outputs, and keep productivity fields populated.

---

### Edge Case 10: Multiple Indels Across Different Regions

**Biological context**: In heavily mutated antibodies (e.g., HIV bnAbs like VRC01 or 10E8), multiple indels can occur in different regions of the same sequence. This tests the annotator's ability to handle cumulative effects of multiple indels on region boundary positions.

#### 10a: 3-nt deletion in FWR1 + 3-nt insertion in FWR3

**Modification**: Apply two codon-length indels in different framework regions.

**Example**:
```
Modified:
  - Delete 3 nt at FWR1 position +15
  - Insert "AGC" at FWR3 position +20 (adjusted for prior deletion)

Expected behavior:
  - FWR1 should be 3 shorter than ground truth
  - FWR3 should be 3 longer than ground truth
  - CDR1, CDR2 (between the indels) should remain stable, with tolerance around adjacent boundaries
  - Net length change is 0 (in-frame)
  - Sequence could still be productive depending on downstream rule checks
```

#### 10b: Insertion in CDR1 + Deletion in CDR2 + Insertion in FWR3

**Modification**: Three separate codon-length indels.

**Expected behavior**: Each affected region should show the expected length change; regions between indels should be approximately unchanged.

#### 10c: Multiple non-codon-length indels summing to codon-length

**Modification**: 1-nt deletion in FWR2 + 2-nt deletion in FWR3 = -3 (in-frame).

**Expected behavior**: Despite individual frame disruptions, the net effect is in-frame. The annotator should detect both indels and preserve coherent region extraction; productivity is asserted from rule-based outputs.

---

### Edge Case 11: Stop Codons

**Biological context**: Stop codons in the coding region make a sequence non-productive. They can arise from SHM point mutations or from frameshifts. The annotator checks for stop codons during productivity assessment. Region extraction should still work correctly even when stop codons are present.

#### 11a: Stop codon in CDR3

**Modification**: Replace a codon in CDR3 with TAA (stop codon).

**Example**:
```
Ground truth CDR3: gcgagaggcgttttagtggctgg...

Modified: replace codon at position +3 with TAA
  gcgTAAgcgttttagtggctgg...

Expected behavior:
  - result["productive"] == False
  - result["stop_codon"] == True
  - `result["productivity_issues"]` includes "stop codon" text
  - All region sequences should still be extracted
  - FWR1, CDR1, FWR2, CDR2, FWR3 should match ground truth exactly
  - CDR3 should contain the stop codon mutation
```

#### 11b: Stop codon in FWR3

**Modification**: Replace a codon in FWR3 with TAG (stop codon).

**Expected behavior**: Same as 11a -- non-productive, `stop_codon == True`, stop-codon reason in `productivity_issues`, regions still extracted, upstream regions unchanged.

#### 11c: Multiple stop codons

**Modification**: Introduce stop codons in both FWR2 and CDR3.

**Expected behavior**: Non-productive, `stop_codon == True`, stop-codon reason in `productivity_issues`, all regions still extracted.

---

### Edge Case 12: Region Consistency Checks

**Biological context**: These are not separate biological edge cases but cross-cutting validation checks that should hold for any annotated sequence. They verify internal consistency of the annotation output.

#### 12a: Region concatenation matches oriented sequence

**Test**: For all 50 ground truth sequences **and representative generated edge-case sequences**, verify that `fwr1 + cdr1 + fwr2 + cdr2 + fwr3 + cdr3 + fwr4` equals the full oriented sequence (or an expected subsequence for truncated cases).

#### 12b: AA regions are translations of NT regions

**Test**: For each region in baseline and edge-case outputs, verify that translating the NT region produces the AA region when NT length is divisible by 3.

```python
import abutils
for region in ["fwr1", "cdr1", "fwr2", "cdr2", "fwr3", "cdr3", "fwr4"]:
    nt = result[region]
    aa = result[f"{region}_aa"]
    if nt and len(nt) % 3 == 0:
        assert abutils.tl.translate(nt) == aa
```

#### 12c: NT region lengths are multiples of 3 (for productive sequences)

**Test**: For productive sequences, all NT regions should have lengths that are multiples of 3. For non-productive sequences, assert only region extraction consistency (do not force modulo-3 on every region).

#### 12d: Heavy vs light chain region patterns

**Test**: Verify that heavy chains have "IGH" locus and light chains have "IGK" or "IGL" locus. Heavy chains should have D-gene calls when available; light chains should not.

---

### Edge Case 13: Reverse-Complement / Orientation Robustness

**Biological context**: Input sequences can be provided in either orientation. Assignment/orientation logic should normalize reverse-complemented inputs and preserve biological annotations.

#### 13a: Reverse-complemented heavy chain input

**Modification**: Reverse-complement a known heavy chain sequence from `test_50.csv` and run through `abstar.run()`.

**Expected behavior**:
- Pipeline should orient sequence correctly and complete without crash.
- Locus and gene calls should remain coherent with the original forward sequence.
- Region concatenation and CDR3/junction outputs should be biologically equivalent to forward-input annotation.

#### 13b: Reverse-complemented light chain input

**Modification**: Same as 13a, using both kappa and lambda examples.

**Expected behavior**:
- Same invariants as 13a, with light-chain-specific locus expectations (IGK/IGL).

---

### Edge Case 14: Ambiguous Nucleotides Near Critical Boundaries

**Biological context**: Real sequencing reads often contain ambiguous base calls (`N`). Ambiguity can occur near region boundaries and should not break extraction.

#### 14a: Single `N` near CDR1/FWR2 boundary

**Modification**: Replace one base within +/-3 nt of CDR1/FWR2 boundary with `N`.

**Expected behavior**:
- Pipeline should not crash; regions are still extracted.
- Boundary-adjacent regions should remain length-stable unless alignment uncertainty requires minor tolerance.
- `productivity_issues` should include ambiguous nucleotide text.

#### 14b: Multiple `N` bases near FWR3/CDR3 boundary

**Modification**: Introduce 3-5 `N` calls across FWR3/CDR3 boundary.

**Expected behavior**:
- CDR3/junction extraction remains bounded and non-empty when biologically present.
- Productivity fields (`productive`, `productivity_issues`) are populated consistently.

---

### Edge Case 15: Degenerate Alignment Outputs / Missing Region Coordinates

**Biological context**: Extreme truncation or weak alignment can produce missing coordinate mappings in `get_region_sequence()` (`region_start`/`region_end` may be unresolved). This path must fail gracefully.

#### 15a: `get_region_sequence()` with unresolved coordinate mapping

**Modification**: Craft unit-level alignment input that forces unresolved start/end mapping for a target region.

**Expected behavior**:
- Function returns gracefully (no exception).
- Return contract is validated via normalized tuple output.
- Empty-sequence behavior is asserted with implementation-accurate expectations.

#### 15b: Integration-level severely degraded input

**Modification**: Apply deep truncation + clustered mutations to reduce alignment confidence without introducing invalid input types.

**Expected behavior**:
- Annotation run does not crash.
- Region fields remain present (possibly empty where appropriate).
- Consistency checks (concatenation, bounded lengths) still hold.

---

### Edge Case 16: `identify_cdr3_regions()` Fallback Paths

**Biological context**: `identify_cdr3_regions()` has fallback logic when positional anchors are missing. These paths should be tested directly to avoid silent CDR3 partitioning errors.

#### 16a: Missing J positional anchors (fallback string matching)

**Modification**: Unit-test `identify_cdr3_regions()` with `j_sequence_start`/`j_sequence_end` unset while providing valid sequence context.

**Expected behavior**:
- Fallback search path is used.
- `cdr3_j`/`cdr3_j_aa` outputs are bounded and frame-adjusted as designed.

#### 16b: Missing D positional anchors for heavy-chain CDR3 partitioning

**Modification**: Unit-test heavy-chain object with D-call present but missing D positional anchors.

**Expected behavior**:
- Fallback D search is constrained to CDR3 search window.
- `cdr3_v`, `cdr3_n1`, `cdr3_d`, `cdr3_n2`, `cdr3_j` partitions remain non-overlapping and bounded.

---

## Unit Tests for `get_region_sequence()`

These tests bypass the full pipeline and test the region extraction function directly with crafted alignment objects. They are faster, deterministic, and target specific code paths.

Important contract reminder: `get_region_sequence()` returns a tuple:

```python
(region_start, region_end, region_sequence)
```

Current implementation has a compatibility edge case where fully missing regions may return just `""`. Unit tests should normalize return values before assertion.

Unit tests should validate coordinates where behavior depends on boundary correction logic, not only the sequence string.

### Unit Test Setup Pattern

Following the existing pattern in `test_regions.py`:

```python
from ..annotation.antibody import Antibody
from ..annotation.regions import get_region_sequence, identify_cdr3_regions

def make_alignment(sequence, germline):
    """Create alignment objects for testing."""
    return abutils.tl.semiglobal_alignment(sequence, germline)

@pytest.fixture
def antibody():
    return Antibody(sequence_id="test_unit")

def normalize_region_output(result):
    # Compatibility normalization for missing-region path that may return ""
    if isinstance(result, tuple):
        return result
    return None, None, result

def extract_region(...):
    start, end, seq = normalize_region_output(get_region_sequence(...))
    return start, end, seq
```

### Unit Test: Non-codon boundary gap (codon-stealing logic)

Tests the specific edge case handled at `regions.py:174-200`.

```python
def test_noncodon_boundary_gap_triggers_codon_stealing():
    """
    A non-codon-length gap at a region boundary should trigger
    the codon-stealing logic that adjusts region endpoints.

    Scenario:
              FWR1-----><----CDR1
    QUERY:    GACGTGGA---GGTGGAGTC
              || ||| |   |||||||||
    GERMLINE: GAGGTGCAGCTGGTGGAGTC

    The 3-nt deletion spans the boundary. The aligned query has a gap at
    the end of FWR1. If the gap is non-codon-length (e.g., 1 or 2 of the 3
    gap chars fall in FWR1 and 1 or 2 fall in CDR1), the codon should be
    assigned to the region where it starts.

    Assert:
      - tuple return shape
      - adjusted start/end behavior (codon-stealing)
      - no '-' in returned V-region sequence
    """
```

### Unit Test: AA alignment truncation correction

Tests the edge case at `regions.py:149-167`.

```python
def test_aa_alignment_truncation_corrected_by_nt_start():
    """
    When nt_region_start=0 but the AA alignment incorrectly sets region_start>0
    (due to mutations in the first few AAs causing alignment gaps), the function
    should correct the AA region start to 0.

    Assert:
      - returned AA start coordinate is corrected to 0
      - AA sequence includes mutated leading residues
    """
```

### Unit Test: Fully missing region returns empty string

```python
def test_fully_missing_region_returns_empty():
    """When germline_start is beyond a region's IMGT end position,
    get_region_sequence should return an empty sequence payload (normalized)."""
```

### Unit Test: Insertion at IMGT gap position

```python
def test_insertion_at_imgt_gap_position():
    """An insertion exactly where the IMGT gapped germline has dots
    should be correctly handled by the position mapping functions.

    Assert returned coordinates are valid and sequence is gap-stripped."""
```

---

## Implementation Sequence

1. **Step 1**: Add ground truth fixtures to `conftest.py`
2. **Step 2**: Create `edge_case_helpers.py` with all sequence modification functions, including deterministic mutation behavior
3. **Step 3**: Create `test_region_edge_cases.py` with baseline validation tests (all 50 sequences)
4. **Step 4**: Add unit tests for `get_region_sequence()` edge cases
5. **Step 5**: Add integration tests for edge cases 1-3 (user-specified priority cases)
6. **Step 6**: Add integration tests for edge cases 4-16
7. **Step 7**: Split execution into core deterministic matrix vs extended stress matrix (to control CI runtime/brittleness)
8. **Step 8**: Run full suite, identify failures that represent actual bugs vs. test design issues, refine assertions

## Verification

```bash
# Run just the new edge case tests
pytest abstar/tests/test_region_edge_cases.py -v

# Run with the existing region tests to ensure no regressions
pytest abstar/tests/test_regions.py abstar/tests/test_region_edge_cases.py -v

# Re-run deterministic subset to verify stability
pytest abstar/tests/test_region_edge_cases.py -k "core and not stress" -vv
pytest abstar/tests/test_region_edge_cases.py -k "core and not stress" -vv

# Run the full test suite
pytest -v
```

Execution matrix guidance:

- `core`: deterministic representative cases for each edge-case class, suitable for CI.
- `stress`: expanded combinatorics (more mutation counts, more sequences) that can run in nightly/extended jobs.
